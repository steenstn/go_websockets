<style>
    canvas {
        border: 1px solid #666;
        image-rendering: optimizeSpeed; /* Older versions of FF          */
        image-rendering: -moz-crisp-edges; /* FF 6.0+                       */
        image-rendering: -o-crisp-edges; /* OS X & Windows Opera (12.02+) */
        image-rendering: pixelated; /* Awesome future-browsers       */
        -ms-interpolation-mode: nearest-neighbor; /* IE                            */
        position: absolute;
        top: 20%;
        left: 20%;
    }
</style>
<pre id="output"></pre>
<input id="input" type="text" value="localhost:8080"/>
<button onclick="connectAndInitialize()">Connect</button>
<canvas id="c"></canvas>
<script>

    let autoConnect = true;
    let socket;
    let keyDownCounter = 0;
    const MessageType = {
        TextMessage: 0,
        PositionUpdate: 1,
    };
    const levelWidth = 640;
    const levelHeight = 480;
    let c = document.getElementById('c');

    let input = document.getElementById("input");
    c.width = levelWidth;
    c.height = levelHeight;
    let ctx = c.getContext('2d');
    ctx.fillStyle = "#000";
    let output = document.getElementById("output");

    let keysDown = {};
    let keysHit = {};

    if (autoConnect) {
        connectAndInitialize();
    }

    function connectAndInitialize() {
        socket = new WebSocket("ws://" + input.value + "/game");
        addEventListener("keydown", function (e) {
            keysDown[e.key] = true;
            keyDownCounter++;
            if (keyDownCounter === 1) {
                keysHit[e.key] = true;
            }
        }, false);

        addEventListener("keyup", function (e) {
            console.log(e.key)
            if (e.key === "ArrowUp") {
                socket.send("down");
            }
            keyDownCounter = 0;
            delete keysDown[e.key];
            delete keysHit[e.key];
        }, false);


        socket.onopen = () => {
            output.innerHTML += "Status: Connected\n";
        };

        socket.onmessage = function (e) {
            //console.log("Server: " + e.data)
            let json = JSON.parse(e.data)
            let type = json.Type
            let message = atob(json.Msg);
            switch (type) {
                case MessageType.TextMessage:
                    ctx.fillText(message, 10, 50);
                    break;
                case MessageType.PositionUpdate:
                    handlePositionUpdate(message);
                    break;
                default:
                    console.log("Unknown type " + type)
            }

        };

        setInterval(gameLoop, 30);
    }

    let drawShip = (x, y, direction) => {
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        /*
                ctx.moveTo(x-10*Math.cos(direction+Math.PI/2), y+10*Math.sin(direction+Math.PI/2));
                ctx.lineTo(x+10*Math.cos(direction-Math.PI/2), y+10*Math.sin(direction-Math.PI/2));
                ctx.lineTo(x+Math.cos(direction), y-10*Math.sin(direction));
                */

        ctx.moveTo(x-5 + 10 * Math.cos(direction + Math.PI / 2), y-5 + 10 * Math.sin(direction + Math.PI / 2));
        ctx.lineTo(x-5 + 10*Math.cos(direction-Math.PI/2), y-5+10*Math.sin(direction-Math.PI/2));
        ctx.lineTo(x-5 + 10*Math.cos(direction), y-5 + 10*Math.sin(direction));
       ctx.fill()

        //ctx.lineTo(x + 15 * Math.cos(players[i].Direction), y + 15 * Math.sin(players[i].Direction));
        //ctx.fill();
    }

    function handlePositionUpdate(message) {
        let data = JSON.parse(message);
        //console.log(data)
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, levelWidth, levelHeight);
        let players = data.Players;
        for (let i = 0; i < players.length; i++) {
            let x = players[i].X;
            let y = players[i].Y;
           // ctx.fillRect(x, y, 10, 10);
            drawShip(x, y, players[i].Direction);
            /*
                        ctx.beginPath();
                        ctx.moveTo(x + 5, y + 5);
                        ctx.lineTo(x + 15 * Math.cos(players[i].Direction), y + 15 * Math.sin(players[i].Direction));
                        ctx.stroke();*/
        }

        ctx.fillStyle = "#afafaf"
        let asteroids = data.Asteroids;
        for (let i = 0; i < asteroids.length; i++) {
            let x = asteroids[i].X;
            let y = asteroids[i].Y;
            ctx.beginPath();
            ctx.arc(x,y,asteroids[i].Size*5, 0, 2 * Math.PI);
            ctx.fill();
            //ctx.fillRect(x, y, asteroids[i].Size * 10, asteroids[i].Size * 10);
        }
        ctx.fillStyle = "#fff"
        let bullets = data.Bullets;
        for (let i = 0; i < bullets.length; i++) {
            let x = bullets[i].X;
            let y = bullets[i].Y;
            ctx.fillRect(x, y, 3, 3);
        }
    }

    function gameLoop() {
        if ("ArrowUp" in keysDown) {
            socket.send("up");
        } else if ("ArrowDown" in keysDown) {
            socket.send("down");
        }
        if ("ArrowLeft" in keysDown) {
            socket.send("left");
        } else if ("ArrowRight" in keysDown) {
            socket.send("right");
        }
        if ("x" in keysHit) {
            socket.send("space");
            delete keysHit["x"];
        }
    }

</script>
